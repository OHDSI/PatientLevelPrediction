# @file fitGLMModel.R
#
# Copyright 2019 Observational Health Data Sciences and Informatics
#
# This file is part of PatientLevelPrediction
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#' Fit a predictive model
#'
#' @param population   A population object generated by \code{createStudyPopulation}, potentially filtered by other functions.
#'
#' @param plpData       An object of type \code{plpData} as generated using
#'                               \code{getDbPlpData}.
#' @param modelType              The type of outcome model that will be used. Possible values are
#'                               "logistic", "poisson", or "cox".
#' @param excludeCovariateIds    Exclude these covariates from the outcome model.
#' @param includeCovariateIds    Include only these covariates in the outcome model.
#' @param prior                  The prior used to fit the model. See
#'                               \code{\link[Cyclops]{createPrior}} for details.
#' @param control                The control object used to control the cross-validation used to
#'                               determine the hyperparameters of the prior (if applicable). See
#'                               \code{\link[Cyclops]{createControl}} for details.
#'
#' @export
fitGLMModel <- function(population,
                            plpData,
                            modelType = "logistic",
                            excludeCovariateIds = c(),
                            includeCovariateIds = c(),
                            prior = createPrior("laplace", useCrossValidation = TRUE),
                            control = createControl(cvType = "auto",
                                                    fold=3,
                                                    startingVariance = 0.01,
                                                    tolerance  = 2e-06,
                                                    cvRepetitions = 1,
                                                    selectorType = "byPid",
                                                    noiseLevel = "silent",
                                                    threads=-1,
                                                    maxIterations = 3000)) {

  
  start <- Sys.time()
  if (nrow(population) == 0) {
    status <- "NO SUBJECTS IN POPULATION, CANNOT FIT"
  } else if (sum(population$outcomeCount) == 0) {
    status <- "NO OUTCOMES FOUND FOR POPULATION, CANNOT FIT"
  }  else {
    colnames(population)[colnames(population) == "outcomeCount"] <- "y"
    

    covariates <- limitCovariatesToPopulation(plpData$covariates, ff::as.ff(population$rowId))
    
    if (length(includeCovariateIds) != 0) {
      idx <- !is.na(ffbase::ffmatch(covariates$covariateId, ff::as.ff(includeCovariateIds)))
      covariates <- covariates[ffbase::ffwhich(idx, idx == TRUE), ]
    }
    if (length(excludeCovariateIds) != 0) {
      idx <- is.na(ffbase::ffmatch(covariates$covariateId, ff::as.ff(excludeCovariateIds)))
      covariates <- covariates[ffbase::ffwhich(idx, idx == TRUE), ]
    }
    
    if (modelType == "cox"){
      population$y[population$y != 0] <- 1
      population$time <- population$survivalTime
    } else if (modelType == "logistic"){
      population$y[population$y != 0] <- 1
    } else if (modelType == "poisson"){
      population$time <- population$timeAtRisk
    }
    if (modelType == "cox") {
      addIntercept <- FALSE
    } else {
      addIntercept <- TRUE
    }
    cyclopsData <- Cyclops::convertToCyclopsData(outcomes = ff::as.ffdf(population[,!colnames(population)%in%c('cohortStartDate')]),
                                                 covariates = covariates,
                                                 addIntercept = addIntercept,
                                                 modelType = modelTypeToCyclopsModelType(modelType),
                                                 checkSorting = TRUE,
                                                 checkRowIds = FALSE,
                                                 normalize = NULL,
                                                 quiet = TRUE)
    fit <- tryCatch({
      ParallelLogger::logInfo('Running Cyclops')
      Cyclops::fitCyclopsModel(cyclopsData, prior = prior, control = control)}, 
      finally = ParallelLogger::logInfo('Done.'))
    if (is.character(fit)) {
      coefficients <- c(0)
       status <- fit
    } else if (fit$return_flag == "ILLCONDITIONED") {
      coefficients <- c(0)
        status <- "ILL CONDITIONED, CANNOT FIT"
        ParallelLogger::logWarn(paste("GLM fitting issue: ", status))
    } else if (fit$return_flag == "MAX_ITERATIONS") {
      coefficients <- c(0)
       status <- "REACHED MAXIMUM NUMBER OF ITERATIONS, CANNOT FIT"
       ParallelLogger::logWarn(paste("GLM fitting issue: ", status))
    } else {
      status <- "OK"
      coefficients <- stats::coef(fit) # not sure this is stats??
      ParallelLogger::logInfo(paste("GLM fit status: ", status))
       }
  }
  outcomeModel <- attr(population, "metaData")
  outcomeModel$coefficients <- coefficients
  #outcomeModel$outcomeModelPriorVariance <- priorVariance
  outcomeModel$priorVariance <- fit$variance
  outcomeModel$log_likelihood <- fit$log_likelihood
  outcomeModel$modelType <- modelType
  outcomeModel$modelStatus <- status
  outcomeModel$populationCounts <- getCounts(population, "Population count")
  if (modelType == "poisson" || modelType == "cox") {
    timeAtRisk <- data.frame(sum(population$time))
    outcomeModel$timeAtRisk <- timeAtRisk
  }
  class(outcomeModel) <- "plpModel"
  delta <- Sys.time() - start
  ParallelLogger::logInfo(paste("Fitting model took", signif(delta, 3), attr(delta, "units")))
  return(outcomeModel)
}

modelTypeToCyclopsModelType <- function(modelType, stratified=F) {
  if (modelType == "logistic") {
    if (stratified)
      return("clr")
    else
      return("lr")
  } else if (modelType == "poisson") {
    if (stratified)
      return("cpr")
    else
      return("pr")
  } else if (modelType == "cox") {
    return("cox")
  } else {
    ParallelLogger::logError(paste("Unknown model type:", modelType))
    stop()
  }

}

#' Get the predictive model details
#'
#' @description
#' \code{getModelDetails} shows the full model, so showing the betas of all variables included in the
#' model, along with the variable names
#'
#' @param predictiveModel   An object of type \code{predictiveModel} as generated using he
#'                          \code{\link{fitPlp}} function.
#' @param plpData           An object of type \code{plpData} as generated using
#'                          \code{\link{getPlpData}}.
#'
#' @details
#' Shows the coefficients and names of the covariates with non-zero coefficients.
#'
#' @export
getModelDetails <- function(predictiveModel, plpData) {
  cfs <- predictiveModel$coefficients
  
  cfs <- cfs[cfs != 0]
  attr(cfs, "names")[attr(cfs, "names") == "(Intercept)"] <- 0
  cfs <- data.frame(coefficient = cfs, id = as.numeric(attr(cfs, "names")))
  
  cfs <- merge(ff::as.ffdf(cfs),
               plpData$covariateRef,
               by.x = "id",
               by.y = "covariateId",
               all.x = TRUE)
  cfs <- ff::as.ram(cfs[, c("coefficient", "id", "covariateName")])
  cfs$covariateName <- as.character(cfs$covariateName)
  cfs <- cfs[order(-abs(cfs$coefficient)), ]
  cfs$covariateName[cfs$id == 0] <- "Intercept"
  return(cfs)
}
